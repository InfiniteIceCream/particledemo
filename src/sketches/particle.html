---
title: Particle
layout: sketch.njk
---

{% block sketch %}




  <script>

  let nextMass
  let nextChargeDensity
  let particles = []


  class Particle {
    constructor(x, y, mass, chargeDensity) {
      this.position = createVector(x, y)
      this.velocity = createVector(0, 0)
      this.acceleration = createVector(0, 0)
      this.mass = mass
      this.radius = sqrt(mass)*10
      this.chargeDensity = chargeDensity
      this.charge = this.chargeDensity * mass
      this.collisions = 0
    }

    update() {

      // find net force from other particles
      let netForce = createVector(0, 0)
      for (let i = 0; i < particles.length; i++) {
        let p = particles[i]
        let sideA = p.position.x - this.position.x
        let sideB = p.position.y - this.position.y
        let hypotenuse = createVector(sideA, sideB)
        let dist = hypotenuse.mag()

        if (dist !== 0) { // only find force from particles in a different position
          let angle = hypotenuse.heading()
          let force = -(this.charge * p.charge)/dist/1000 // positive force = pull, negative force = push
          let forceVector = createVector(force*cos(angle), force*sin(angle))

          if (dist < (this.radius + p.radius) / 2) { // check for collision
            let relativeVelocity = this.velocity.sub(p.velocity)
            this.velocity.add(p.velocity)
            let collisionVel = relativeVelocity.dot(hypotenuse)
            if (collisionVel > 0) {
              let collisionVelVector = p5.Vector.fromAngle(angle, collisionVel/2)
              this.velocity.sub(collisionVelVector.div(this.mass))
              collisionVelVector.mult(this.mass)
              p.velocity.add(collisionVelVector.div(p.mass))
              this.collisions += 1
              p.collisions += 1
            }
          }

          netForce.add(forceVector)
        }
      }

      if ((this.position.x < 0 + this.radius/2 && this.velocity.x < 0) || (this.position.x > width - this.radius/2 && this.velocity.x > 0)) {
        this.velocity.x *= -1
      }

      if ((this.position.y < 0 + this.radius/2 && this.velocity.y < 0) || (this.position.y > height - 150 - this.radius/2 && this.velocity.y > 0)) {
        this.velocity.y *= -1
      }

      this.acceleration = createVector(netForce.x/this.mass, netForce.y/this.mass)
      this.velocity.add(this.acceleration)
      this.position.add(this.velocity)
    }

    display() {
      noStroke()
      fill(128+this.chargeDensity, 128-this.chargeDensity, 128-this.chargeDensity)
      ellipse(this.position.x, this.position.y, this.radius, this.radius)
      fill(0)
      text(this.collisions, this.position.x, this.position.y)
    }
  }


  function setup() {
    let myCanvas = createCanvas(1000, 600)
    myCanvas.parent("sketch-holder")
  }

  let massSliderX = 25
  let chargeSliderX = 25
  let draggingMassSlider = false
  let draggingChargeSlider = false


  function draw() {

    background(240)
    for (i = 0; i < particles.length; i++) {
      particles[i].update()
      particles[i].display()
    }

    noStroke()
    fill(0, 0, 0)
    text("Number of particles: " + particles.length, 10, 20)


    // sliders
    fill(192)
    rect(0, height-150, width, 150)

    stroke(0)
    fill(128)
    rect(20, 500, 150, 10, 10)
    rect(20, 550, 150, 10, 10)

    if (sqrt((mouseX-massSliderX)**2+(mouseY-505)**2) < 7.5) {
      fill(64)
      if (mouseIsPressed) {
        draggingMassSlider = true
      }
    } else {
      fill(96)
    }
    ellipse(massSliderX, 505, 15, 15)

    if (draggingMassSlider) {
      massSliderX = max(min(mouseX, 165), 25)
      if (mouseIsPressed === false) {
        draggingMassSlider = false
      }
    }


    if (sqrt((mouseX-chargeSliderX)**2+(mouseY-555)**2) < 7.5) {
      fill(64)
      if (mouseIsPressed) {
        draggingChargeSlider = true
      }
    } else {
      fill(96)
    }
    ellipse(chargeSliderX, 555, 15, 15)

    if (draggingChargeSlider) {
      chargeSliderX = max(min(mouseX, 165), 25)
      if (mouseIsPressed === false) {
        draggingChargeSlider = false
      }
    }

    if (sqrt((chargeSliderX-25)**2+(mouseY-555)**2) < 7.5) {
      fill(64)
    } else {
      fill(96)
    }
    ellipse(chargeSliderX, 555, 15, 15)



    nextMass = map(massSliderX, 25, 165, 1, 10)
    nextChargeDensity = map(chargeSliderX, 25, 165, -128, 128)

    noStroke()
    fill(0)
    text("Next mass: " + floor(nextMass), 20, 490)
    text("Next charge: " + floor(nextChargeDensity), 20, 540)

    stroke(0)
    fill(255)
    rect(200, 500, 50, 50)

    noStroke()
    fill(128+nextChargeDensity, 128-nextChargeDensity, 128-nextChargeDensity)
    ellipse(225, 525, sqrt(nextMass)*10, sqrt(nextMass)*10)
    


    // clear particles
    if (keyIsDown(LEFT_ARROW)) {
      particles = []
    }
  }

  // create new particle on click
  function mousePressed() {
    if (mouseY < 450) {
      particles.push(new Particle(mouseX, mouseY, nextMass, nextChargeDensity))
    }
  }




  </script>
{% endblock sketch %}

{% block content %}
<p>Click to spawn a particle!</p>
<div id="sketch-holder"></div>
<pre><code>

</code></pre>
{% endblock content %}